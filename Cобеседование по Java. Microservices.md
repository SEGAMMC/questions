# Cобеседование по Java Микросервисы. Разбор вопросов и ответов.


<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />
  </a>&nbsp;&nbsp;


Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov




## 1. Что вы знаете о микросервисах?

Микросервисы - это архитектурный подход к разработке программного обеспечения, в котором приложение разбивается на небольшие и независимые сервисы, каждый из которых выполняет конкретную функцию. Каждый микросервис может быть разработан, развернут и масштабирован независимо от других сервисов в приложении.

Преимущества микросервисной архитектуры:
Гибкость и масштабируемость: Микросервисы позволяют разрабатывать и масштабировать каждый сервис независимо, что облегчает внесение изменений и обеспечивает гибкость в разработке приложений.

Отказоустойчивость: Если один микросервис выходит из строя, остальные сервисы продолжают работать, что повышает отказоустойчивость системы в целом.

Улучшенная командная работа: Каждый микросервис может быть разработан и поддерживаться отдельной командой, что способствует более эффективной командной работе и ускоряет процесс разработки.

Технологичесное разнообразие: Микросервисы позволяют использовать различные технологии и языки программирования для каждого сервиса, в зависимости от его потребностей.

Основные компоненты микросервисной архитектуры:
Сервисный реестр (Service Registry): Это компонент, который отслеживает доступные микросервисы и их местоположение. Он позволяет другим сервисам обнаруживать и взаимодействовать с нужными сервисами.

Circuit Breaker: Это механизм, который предотвращает распространение сбоев в системе. Он обеспечивает отказоустойчивость, переключая запросы на альтернативные сервисы или возвращая значения по умолчанию, если сервис недоступен.

API Gateway: Это компонент, который предоставляет единый точку входа для клиентов и маршрутизирует запросы к соответствующим микросервисам.

Saga Pattern: Это паттерн, который обеспечивает согласованность данных и выполнение транзакций в распределенной среде. Он используется для управления долгоживущими транзакциями, которые включают несколько микросервисов.

Event Sourcing Pattern: Это паттерн, который сохраняет все изменения состояния системы в виде событий. Он позволяет восстанавливать состояние системы на основе событий и обеспечивает аудит и воспроизводимость данных.

Command Query Responsibility Segregation (CQRS): Это паттерн, который разделяет операции записи и операции чтения в системе. Он позволяет оптимизировать производительность и масштабируемость системы, разделяя обработку команд и запросов.

Bulkhead Pattern: Это паттерн, который изолирует компоненты системы друг от друга, чтобы предотвратить распространение сбоев. Он обеспечивает отказоустойчивость и предотвращает полное отключение системы при сбое одного компонента.

Backends for Frontends (BFF): Это паттерн, который предоставляет отдельные бэкенды для различных клиентских интерфейсов. Он позволяет оптимизировать взаимодействие между клиентами и микросервисами, предоставляя специфические API для каждого клиента.


## 2. Каковы характеристики микросервисов?

Микросервисы - это архитектурный подход, в котором приложение разбивается на небольшие независимые компоненты, называемые микросервисами. Каждый микросервис выполняет определенную функцию и может быть разработан, развернут и масштабирован независимо от других микросервисов.

Вот некоторые характеристики микросервисов:

+ Разделение обязанностей: Каждый микросервис отвечает только за определенную функцию или задачу. Это позволяет разработчикам сосредоточиться на конкретной функциональности и упрощает поддержку и развитие приложения.
+ Независимость: Микросервисы могут быть разработаны, развернуты и масштабированы независимо друг от друга. Это означает, что разработчики могут обновлять и изменять каждый микросервис отдельно, без влияния на остальные компоненты системы.
+ Гибкость: Микросервисы могут быть написаны на разных языках программирования и использовать различные технологии и инструменты. Это позволяет командам разработчиков использовать наиболее подходящие технологии для каждого микросервиса и упрощает интеграцию с другими системами.
+ Масштабируемость: Благодаря независимости каждого микросервиса, их можно горизонтально масштабировать, добавляя новые экземпляры микросервисов при необходимости. Это позволяет обрабатывать большие объемы трафика и обеспечивает высокую отказоустойчивость системы.
+ Легкость развертывания: Микросервисы могут быть развернуты отдельно, что упрощает процесс развертывания и обновления приложения. Каждый микросервис может быть развернут на отдельном сервере или контейнере, что улучшает изоляцию и безопасность.
+ Легкость тестирования: Микросервисы могут быть легко тестированы в изоляции. Это позволяет разработчикам быстро проверять функциональность каждого микросервиса и обнаруживать ошибки и проблемы на ранних стадиях разработки.

В целом, микросервисы обеспечивают гибкую и масштабируемую архитектуру, которая позволяет разработчикам эффективно разрабатывать, развертывать и масштабировать сложные приложения.

## 3. Каковы лучшие практики разработки микросервисов?

Разработка микросервисов является широко распространенной практикой в современной архитектуре программного обеспечения. Вот некоторые из лучших практик, которые помогут вам успешно разрабатывать микросервисы:

Разделение функциональности: Разбейте ваше приложение на отдельные микросервисы, каждый из которых отвечает только за определенную функцию или возможность. Это поможет упростить разработку, развертывание и масштабирование вашей системы.

Контейнеризация: Используйте контейнеры, такие как Docker, для упаковки и изоляции каждого микросервиса. Это позволяет легко развертывать и масштабировать микросервисы, а также обеспечивает независимость их работы.

Коммуникация через API: Определите четкий и гибкий интерфейс для взаимодействия между микросервисами. Используйте RESTful API или сообщения, такие как RabbitMQ или Apache Kafka, для обмена данными между сервисами.

Надежность и отказоустойчивость: Разработайте микросервисы с учетом возможности отказа других сервисов. Используйте механизмы обработки ошибок, резервное копирование и мониторинг, чтобы обеспечить надежную работу вашей системы.

Масштабируемость: Разрабатывайте микросервисы таким образом, чтобы они могли масштабироваться горизонтально. Это позволит вам управлять растущей нагрузкой, добавляя дополнительные экземпляры сервисов по мере необходимости.

Тестирование: Проводите регулярное модульное и интеграционное тестирование каждого микросервиса, чтобы обеспечить его правильную работу и совместимость с другими сервисами.

Мониторинг и трассировка: Внедрите механизмы мониторинга и трассировки, чтобы отслеживать работу каждого микросервиса и идентифицировать проблемы или узкие места.

Безопасность: Обеспечьте безопасность каждого микросервиса, используя механизмы аутентификации, авторизации и шифрования данных.

Учет этих лучших практик поможет вам создать гибкую, масштабируемую и отказоустойчивую архитектуру микросервисов.

## 4. Как работает микросервисная архитектура?

Микросервисная архитектура - это подход к разработке программного обеспечения, при котором приложение разбивается на небольшие, независимые сервисы, каждый из которых выполняет конкретную функцию. Каждый сервис может быть разработан, развернут и масштабирован независимо от других сервисов в системе. Это позволяет достичь более гибкой и масштабируемой архитектуры, где каждый сервис может быть разработан и поддерживаться отдельной командой разработчиков.

Преимущества микросервисной архитектуры:

+ Гибкость: Микросервисы могут быть разработаны и развернуты независимо друг от друга, что позволяет командам разработчиков работать над ними параллельно и вносить изменения без влияния на другие сервисы.
+ Масштабируемость: Каждый сервис может быть масштабирован отдельно в зависимости от его нагрузки, что позволяет более эффективно использовать ресурсы и обеспечивать высокую производительность системы в целом.
+ Устойчивость к отказам: Если один сервис выходит из строя, остальные сервисы продолжают работать нормально, что обеспечивает более высокую отказоустойчивость системы.
+ Легкость в развертывании и обновлении: Каждый сервис может быть развернут и обновлен независимо от других сервисов, что упрощает процесс развертывания и обновления системы.

Примеры использования микросервисной архитектуры в Java:
+ Spring Boot: Spring Boot является популярным фреймворком для разработки микросервисов на языке Java. Он предоставляет удобные инструменты и библиотеки для создания и развертывания самостоятельных сервисов. Например, Spring Data MongoDB позволяет работать с базой данных MongoDB в микросервисной архитектуре.
+ Java EE: Java EE (Enterprise Edition) также предоставляет набор инструментов и спецификаций для разработки микросервисов на Java. Например, Java EE включает в себя фреймворк Spring MVC для разработки REST API.


## 5. Каковы преимущества и недостатки микросервисной архитектуры?
Микросервисная архитектура имеет несколько преимуществ и недостатков. Вот некоторые из них:

Преимущества микросервисной архитектуры:

+ Гибкость и масштабируемость: Микросервисы могут быть разработаны и развернуты независимо друг от друга, что позволяет гибко масштабировать систему в зависимости от потребностей. Это также упрощает добавление новых функций и изменение существующих без влияния на другие сервисы.
+ Легкость в сопровождении: Каждый микросервис отвечает только за определенную функциональность, что упрощает понимание и сопровождение кода. Команды разработчиков могут работать над разными сервисами независимо друг от друга, что повышает производительность.
+ Устойчивость к сбоям: Если один микросервис выходит из строя, это не приводит к полному отказу системы. Остальные сервисы продолжают работу, что обеспечивает более высокую доступность и надежность системы.
+ Использование разных технологий: Разные микросервисы могут быть разработаны с использованием разных технологий и языков программирования в зависимости от их специфических требований. Это позволяет выбирать наиболее подходящие инструменты для каждого сервиса.

Недостатки микросервисной архитектуры:

+ Сложность управления: Управление микросервисной архитектурой может быть сложным из-за необходимости отслеживать и контролировать множество сервисов. Это может потребовать дополнительных усилий для мониторинга, отладки и обновления каждого сервиса.
+ Сетевая сложность: Взаимодействие между микросервисами происходит через сеть, что может привести к задержкам и потере производительности. Необходимость обеспечения надежности и безопасности сетевого взаимодействия также может быть вызовом.
+ Увеличенные затраты на инфраструктуру: Каждый микросервис требует собственной инфраструктуры и ресурсов, что может повлечь дополнительные затраты на оборудование и поддержку.
+ Сложность тестирования: Тестирование микросервисной архитектуры может быть сложным из-за необходимости проверять взаимодействие между разными сервисами. Это требует более сложной инфраструктуры тестирования и стратегии тестирования.

Несмотря на некоторые недостатки, микросервисная архитектура становится все более популярной из-за своей гибкости и масштабируемости. Решение о ее применении должно быть основано на конкретных потребностях и ограничениях проекта.


## 6. Монолитная, в чем разница между SOA и микросервисной архитектурой?

Монолитная архитектура и микросервисная архитектура - это два разных подхода к разработке и построению программного обеспечения.

Монолитная архитектура представляет собой подход, при котором вся функциональность приложения находится в одном целом - монолите. В монолитной архитектуре все компоненты приложения взаимодействуют непосредственно друг с другом. Все эти компоненты разворачиваются вместе и масштабируются вместе. Обновления и изменения в монолите требуют пересборки всего приложения.

С другой стороны, микросервисная архитектура представляет собой подход, при котором приложение разбивается на небольшие, самостоятельные и независимые сервисы, которые взаимодействуют друг с другом через сетевые вызовы. Каждый сервис выполняет конкретную функцию и может быть развернут, масштабирован и обновлен независимо от других сервисов. Микросервисная архитектура облегчает масштабирование и поддержку приложения, так как изменения и обновления могут быть внесены только в отдельные сервисы, без необходимости пересборки всего приложения.

Основное отличие между монолитной и микросервисной архитектурами заключается в масштабируемости и гибкости. Монолитная архитектура проста в разработке и развертывании, но может стать сложной для масштабирования и поддержки в случае больших и сложных приложений. Микросервисная архитектура обеспечивает большую гибкость и масштабируемость, но требует более сложной инфраструктуры и управления.

В итоге, выбор между монолитной и микросервисной архитектурами зависит от требований и характеристик конкретного проекта. Каждая архитектура имеет свои преимущества и недостатки, и разработчики должны выбирать наиболее подходящий подход в каждом конкретном случае.

## 7. С какими проблемами вы сталкиваетесь при использовании микросервисной архитектуры?

При использовании микросервисной архитектуры могут возникать следующие проблемы:

Сложность управления: Когда у вас есть множество микросервисов, каждый из них требует отдельного управления, мониторинга и масштабирования. Это может привести к сложностям в обнаружении и устранении проблем, а также в управлении зависимостями между сервисами.

Коммуникация и координация: Взаимодействие между микросервисами может быть сложным и требовать дополнительных усилий для обеспечения согласованности данных и управления транзакциями. Координация между различными командами разработчиков также может быть сложной задачей.

Управление данными: Микросервисная архитектура может привести к проблемам с управлением данными, так как каждый сервис обычно имеет свою собственную базу данных. Это может усложнить поиск и анализ данных, а также создание единой истинной версии данных.

Надежность и отказоустойчивость: В микросервисной архитектуре каждый сервис может выходить из строя независимо от других сервисов. Это означает, что необходимо предусмотреть механизмы отказоустойчивости и резервного копирования, чтобы минимизировать простои и сбои в системе.

Культура и организационные изменения: Внедрение микросервисной архитектуры может потребовать изменения в культуре и организации компании. Это может включать в себя изменения в процессах разработки, коммуникации и управлении, а также в разделении обязанностей и ответственности.

Важно отметить, что эти проблемы не являются неизбежными и могут быть решены с помощью правильного планирования, архитектуры и управления проектом. Однако их учет и решение может потребовать дополнительных усилий и ресурсов.

## 8. В чем основное различие между SOA и микросервисной архитектурой?

SOA (Service-Oriented Architecture) и микросервисная архитектура (Microservices Architecture) - это два разных подхода к построению распределенных систем. Вот основные различия между ними:

Масштабирование: SOA подразумевает создание нескольких служб, которые могут быть масштабированы независимо друг от друга. Однако, микросервисная архитектура делит приложение на небольшие, независимые сервисы, каждый из которых может быть масштабирован отдельно.

Гранулярность: SOA обычно ориентирована на создание крупных служб, которые предоставляют большой функционал. В то время как микросервисная архитектура стремится к созданию маленьких, специализированных сервисов, каждый из которых выполняет конкретную функцию.

Коммуникация: В SOA, службы обычно взаимодействуют друг с другом посредством протокола SOAP (Simple Object Access Protocol) или REST (Representational State Transfer). В микросервисной архитектуре, межсервисное взаимодействие часто осуществляется с помощью легковесных протоколов, таких как HTTP или сообщения в стиле "очередей".

Управление данными: SOA обычно использует общую базу данных для хранения и обмена данными между службами. В микросервисной архитектуре, каждый сервис имеет собственную базу данных, что делает их более автономными и изолированными друг от друга.

Гибкость: Микросервисная архитектура предлагает большую гибкость и возможность для независимого развертывания и изменения каждого сервиса. SOA, с другой стороны, может быть менее гибкой из-за более жесткой архитектуры и большого масштаба служб.

В конечном счете, выбор между SOA и микросервисной архитектурой зависит от конкретных требований проекта и контекста использования. Оба подхода имеют свои преимущества и недостатки, и выбор должен быть основан на уникальных потребностях вашей системы.

## 9.  Что такое DDD - Domain Driven Design - Предметно-ориентированное проектирование?

Предметно-ориентированное проектирование (ПОП или DDD) - это подход к разработке программного обеспечения, который заключается в создании специализированного языка программирования или набора инструментов, ориентированных на решение конкретной предметной области или класса задач.

Предметно-ориентированное проектирование позволяет разработчикам создавать программное обеспечение, которое более точно отражает особенности и требования конкретной предметной области. Вместо того чтобы использовать общие языки программирования, такие как Java или C++, разработчики могут создавать специализированные языки, которые лучше соответствуют конкретным задачам и потребностям.

При использовании предметно-ориентированного проектирования разработчики могут создавать модели, описывающие концептуальные аспекты предметной области, и автоматически генерировать исполняемый код на основе этих моделей. Это позволяет сократить время и усилия, затрачиваемые на разработку программного обеспечения, и повысить его качество.

Преимущества предметно-ориентированного проектирования включают более высокую производительность разработки, повышенную читаемость и понятность кода, легкость сопровождения и модификации программного обеспечения, а также возможность повторного использования компонентов.

В общем, предметно-ориентированное проектирование позволяет разработчикам создавать более эффективное и гибкое программное обеспечение, специально адаптированное к конкретным потребностям предметной области.

## 10.  Зачем мне нужен DDD - Domain Driven Design - Предметно-ориентированное проектирование?

Доменно-ориентированный дизайн (DDD) - это подход к разработке программного обеспечения, который помогает организовать код таким образом, чтобы он отражал бизнес-логику и структуру домена предметной области. Основная идея DDD заключается в том, чтобы построить модель системы, которая полностью соответствует бизнес-процессам и предметной области, с которыми работает программа.

Основные преимущества использования DDD в разработке программного обеспечения:

Понятность и легкость сопровождения: DDD помогает создать ясную и понятную модель системы, которая отражает бизнес-логику. Это делает код более легким для чтения, понимания и сопровождения, как для новых разработчиков, так и для существующих членов команды.

Гибкость и масштабируемость: DDD позволяет разбить систему на модули, отражающие различные аспекты предметной области. Это позволяет легко добавлять новые функциональные возможности и изменять существующие без необходимости переписывать весь код. DDD также способствует легкому масштабированию системы при необходимости.

Улучшенное взаимодействие с бизнесом: DDD помогает установить эффективное взаимодействие между разработчиками и бизнес-аналитиками. Благодаря четкому отражению бизнес-логики в коде, разработчики лучше понимают требования и ожидания бизнеса, что способствует более эффективной работе.

Улучшенная тестирование: DDD способствует созданию модульных и независимых от других компонентов системы моделей. Это делает их легкими для тестирования, что повышает качество программного обеспечения.

В целом, использование доменно-ориентированного дизайна в разработке программного обеспечения помогает создать более гибкую, понятную и легко сопровождаемую систему, которая полностью отражает бизнес-процессы и потребности предметной области.


## 11.  Какой язык используется повсеместно?

Микросервисы - это архитектурный подход, при котором приложение разбивается на небольшие независимые сервисы, каждый из которых выполняет определенную функцию. Каждый микросервис может быть разработан на разных языках программирования, в зависимости от предпочтений и требований команды разработчиков.

В повсеместном использовании микросервисов можно выделить несколько языков программирования:

1. Java: Java является одним из самых популярных языков программирования для разработки микросервисов. Он обладает мощной экосистемой и широким сообществом разработчиков.

2. Python: Python также широко используется для разработки микросервисов. Он обладает простым синтаксисом, множеством библиотек и фреймворков, таких как Keras, которые упрощают разработку и интеграцию микросервисов.

3. C#: C# является популярным языком программирования для разработки микросервисов на платформе .NET. Он обладает мощными инструментами и фреймворками, такими как ASP.NET Core, для создания и развертывания микросервисов.

4. Go: Go (или Golang) - это язык программирования, разработанный компанией Google, который становится все более популярным для разработки микросервисов. Он обладает высокой производительностью, простым синтаксисом и встроенной поддержкой параллельных вычислений.

5. JavaScript/Node.js: JavaScript и Node.js также широко используются для разработки микросервисов. Node.js позволяет разрабатывать серверные приложения на JavaScript, что облегчает интеграцию с фронтендом и обеспечивает высокую производительность.

6. Ruby: Ruby - это динамический язык программирования, который также используется для разработки микросервисов. Он обладает простым и выразительным синтаксисом, что упрощает разработку и поддержку кода.

7. Kotlin: Kotlin - это язык программирования, разработанный компанией JetBrains, который становится все более популярным для разработки микросервисов на платформе Java. Он обладает совместимостью с Java и предоставляет множество улучшений в сравнении с ним.

8. Rust: Rust - это системный язык программирования, который также может быть использован для разработки микросервисов. Он обладает высокой производительностью, безопасностью памяти и параллельными возможностями.

Важно отметить, что выбор языка программирования для микросервисов зависит от множества факторов, включая требования проекта, опыт команды разработчиков и экосистему языка. Каждый из перечисленных языков имеет свои преимущества и недостатки, и выбор языка должен быть обоснован исходя из конкретных потребностей проекта.

## 12. Что такое сплоченность?

Сплоченность в контексте микросервисной архитектуры относится к степени взаимосвязи и взаимодействия между отдельными микросервисами. Она описывает, насколько тесно связаны различные компоненты системы и насколько они зависят друг от друга.

Сплоченность является важным понятием в микросервисной архитектуре, так как она влияет на гибкость, масштабируемость и обслуживаемость системы. Высокая степень сплоченности означает, что каждый микросервис выполняет свою специфическую функцию и имеет минимальные зависимости от других сервисов. Это позволяет независимо разрабатывать, развертывать и масштабировать каждый микросервис.

Сплоченность может быть достигнута путем использования принципов SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) и других подходов к проектированию микросервисов. Например, применение принципа единственной ответственности (Single Responsibility Principle) помогает разделить функциональность на отдельные микросервисы, каждый из которых отвечает только за одну задачу.

Важно отметить, что сплоченность не означает полное отсутствие взаимодействия между микросервисами. Взаимодействие между сервисами все равно необходимо для обмена данными и выполнения бизнес-логики. Однако, степень взаимосвязи должна быть минимальной, чтобы обеспечить гибкость и независимость каждого микросервиса.

В итоге, сплоченность в микросервисной архитектуре означает, что каждый микросервис выполняет свою специфическую функцию, имеет минимальные зависимости от других сервисов и может быть разрабатываем, развертываться и масштабироваться независимо.

## 13. Что такое сцепление?

Микросервисы - это архитектурный подход, при котором приложение разбивается на небольшие и независимые сервисы, каждый из которых выполняет отдельную функцию. Каждый микросервис может быть разработан, развернут и масштабирован независимо от других сервисов. Это позволяет достичь гибкости, масштабируемости и легкости разработки и поддержки приложения.

Сцепление (coupling) - это мера зависимости между компонентами системы. В контексте микросервисной архитектуры, сцепление определяет, насколько сильно каждый микросервис зависит от других сервисов или компонентов системы. Чем меньше сцепление, тем более независимыми и модульными являются микросервисы.

Виды сцепления:

Слабое сцепление (loose coupling) - это сцепление, при котором микросервисы имеют минимальные зависимости друг от друга. Каждый сервис может быть разработан и изменен независимо от других сервисов. Это позволяет легко масштабировать и модифицировать систему без влияния на другие сервисы.
Сильное сцепление (tight coupling) - это сцепление, при котором микросервисы имеют сильные зависимости друг от друга. Изменение одного сервиса может потребовать изменений в других сервисах. Это усложняет разработку, тестирование и поддержку системы.
Примеры сцепления в микросервисной архитектуре:

+ Зависимость от внешних API - если один микросервис зависит от другого микросервиса через его API, то изменения в API могут потребовать изменений в зависимом сервисе.
+ Общие базы данных - если несколько микросервисов используют одну и ту же базу данных, изменения в структуре базы данных могут потребовать изменений во всех зависимых сервисах.
+ Синхронные вызовы - если один микросервис синхронно вызывает другой микросервис и ожидает ответа, то изменения в вызываемом сервисе могут привести к проблемам в вызывающем сервисе.


Зачем важно иметь слабое сцепление в микросервисной архитектуре?

+ Гибкость - слабое сцепление позволяет изменять и масштабировать каждый микросервис независимо от других сервисов. Это упрощает разработку и поддержку системы.
+ Модульность - слабое сцепление позволяет разрабатывать и тестировать каждый микросервис отдельно, что способствует повышению качества и ускорению разработки.
+ Распределенность - слабое сцепление позволяет легко масштабировать и развертывать микросервисы на разных серверах или в облаке.

Примеры практик для достижения слабого сцепления:

+ Использование асинхронных сообщений или событий для обмена данными между микросервисами.
+ Использование API-шлюзов или прокси-серверов для скрытия деталей реализации микросервисов и уменьшения зависимостей.
+ Использование контейнеризации и оркестрации для упрощения развертывания и масштабирования микросервисов.


Вывод: Микросервисы - это архитектурный подход, который позволяет разрабатывать гибкие и масштабируемые системы. Сцепление определяет зависимости между микросервисами, и слабое сцепление является желательной практикой для достижения независимости и модульности каждого сервиса.

## 14. Что такое REST / RESTful и какова его цель?

REST (Representational State Transfer) - это архитектурный стиль, который используется для разработки распределенных систем. RESTful - это подход к проектированию веб-сервисов, который следует принципам REST.

Основная цель REST / RESTful состоит в том, чтобы создать веб-сервисы, которые могут быть легко масштабируемы, надежными и расширяемыми. Он стремится к созданию простых, легко понятных и удобных для использования интерфейсов, которые могут быть использованы различными клиентами.

RESTful веб-сервисы основаны на протоколе HTTP и используют его методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами. Они также используют уникальные идентификаторы ресурсов (URL) для доступа к ним.

RESTful веб-сервисы обычно возвращают данные в формате JSON или XML, что делает их легко читаемыми и понятными для клиентов.

Основные принципы REST / RESTful:

+ Client-Server (Клиент-Сервер): Взаимодействие между клиентом и сервером осуществляется через стандартизированный интерфейс.
+ Stateless (Без сохранения состояния): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для его обработки. Сервер не должен сохранять состояние между запросами.
+ Cacheable (Кэшируемость): Ответы сервера могут быть кэшированы на стороне клиента для повторного использования.
+ Uniform Interface (Единый интерфейс): Интерфейс взаимодействия должен быть однородным и простым для понимания.
+ Layered System (Слоистая система): Серверы могут быть разделены на слои, чтобы обеспечить масштабируемость и безопасность.

Пример использования RESTful веб-сервиса: Предположим, у нас есть веб-приложение для управления задачами. Мы можем использовать RESTful веб-сервисы для создания, чтения, обновления и удаления задач.

+ Чтение задачи: GET /tasks/{id}
+ Создание задачи: POST /tasks
+ Обновление задачи: PUT /tasks/{id}
+ Удаление задачи: DELETE /tasks/{id}


RESTful веб-сервисы обеспечивают простоту и гибкость взаимодействия между клиентом и сервером, что делает их популярным выбором для разработки распределенных систем.


## ## 15.  Что вы знаете о Spring Boot?

Spring Boot - это фреймворк для разработки Java-приложений, который упрощает создание микросервисов. Он предоставляет множество функций и инструментов, которые помогают разработчикам быстро создавать и развертывать приложения. Spring Boot автоматически настраивает множество компонентов и библиотек, что позволяет сосредоточиться на разработке бизнес-логики приложения.

Некоторые особенности Spring Boot включают в себя:

Автоматическая конфигурация: Spring Boot автоматически настраивает множество компонентов и библиотек, основываясь на классах и зависимостях, которые вы используете в своем проекте.

Встроенный сервер приложений: Spring Boot поставляется с встроенным сервером приложений, таким как Tomcat или Jetty, что позволяет вам запускать приложение без необходимости настройки отдельного сервера.

Управление зависимостями: Spring Boot упрощает управление зависимостями, позволяя вам указывать зависимости в файле конфигурации и автоматически загружать их при сборке проекта.

Актюаторы: Spring Boot предоставляет актуаторы, которые позволяют мониторить и управлять вашим приложением во время его выполнения. Например, вы можете получить информацию о состоянии приложения, проверить журналы или перезагрузить приложение без его остановки.

Интеграция с другими технологиями: Spring Boot интегрируется с другими популярными технологиями, такими как Spring Data, Spring Security, Spring Cloud и многими другими, что позволяет вам создавать сложные и масштабируемые приложения.



## 16.  Что такое Spring Cloud??


Spring Cloud предоставляет реализации различных паттернов и компонентов, которые помогают разработчикам создавать и управлять микросервисами. Некоторые из ключевых компонентов Spring Cloud включают:

1. Spring Cloud Config: Позволяет централизованно управлять конфигурацией микросервисов, что облегчает изменение конфигурации без необходимости перезапуска приложений.

2. Spring Cloud Netflix: Предоставляет интеграцию с Netflix OSS компонентами, такими как Eureka (для обнаружения служб), Ribbon (для балансировки нагрузки), Hystrix (для обеспечения отказоустойчивости) и другими.

3. Spring Cloud Gateway: Предоставляет возможность создания API-шлюза для маршрутизации запросов к различным микросервисам.

4. Spring Cloud Sleuth: Обеспечивает распределенное трассирование запросов в микросервисной архитектуре, что помогает отслеживать и анализировать производительность и проблемы взаимодействия между сервисами.

5. Spring Cloud Stream: Предоставляет абстракцию для работы с потоковыми данных в микросервисах, позволяя разработчикам легко интегрировать системы обмена сообщениями.

6. Spring Cloud Security: Обеспечивает интеграцию с Spring Security для обеспечения безопасности микросервисов.

Spring Cloud также поддерживает интеграцию с другими популярными технологиями, такими как Kubernetes, Docker, Apache Kafka и другими.

17.  Какие проблемы решает Spring Cloud?

Ниже перечислены некоторые из проблем, которые решает Spring Cloud:

Управление конфигурацией: Spring Cloud позволяет централизованно управлять конфигурацией микросервисов. Это позволяет изменять конфигурацию без перезапуска приложений и обеспечивает гибкость в управлении параметрами приложений.

Регистрация и обнаружение сервисов: Spring Cloud предоставляет инструменты для регистрации и обнаружения микросервисов в распределенной среде. Это позволяет микросервисам находить друг друга автоматически и обеспечивает гибкость в масштабировании и изменении конфигурации системы.

Управление межсервисными вызовами: Spring Cloud предоставляет инструменты для управления межсервисными вызовами, такими как балансировка нагрузки, обработка ошибок и контроль таймаутов. Это обеспечивает надежность и отказоустойчивость взаимодействия между микросервисами.

Цепочки обработки запросов: Spring Cloud позволяет создавать цепочки обработки запросов, где каждый микросервис выполняет определенные операции над запросом. Это позволяет создавать гибкие и масштабируемые системы, где каждый микросервис отвечает только за свою часть функциональности.

Мониторинг и трассировка: Spring Cloud предоставляет инструменты для мониторинга и трассировки микросервисов. Это позволяет отслеживать производительность и состояние системы, а также обнаруживать и исправлять проблемы.

Управление отказами и восстановлением: Spring Cloud предоставляет инструменты для управления отказами и восстановлением в микросервисных системах. Это включает в себя механизмы ретраев, обработку ошибок и автоматическое восстановление после сбоев.

Масштабирование: Spring Cloud предоставляет инструменты для горизонтального масштабирования микросервисов. Это позволяет распределить нагрузку между несколькими экземплярами микросервисов и обеспечить высокую производительность системы.

Управление транзакциями: Spring Cloud предоставляет инструменты для управления транзакциями в распределенных системах. Это позволяет обеспечить целостность данных и согласованность операций между микросервисами.

Spring Cloud предлагает множество других возможностей и инструментов для разработки и управления микросервисными приложениями. Он интегрируется с другими популярными технологиями, такими как Spring Boot, Netflix OSS и Kubernetes, чтобы обеспечить полноценное решение для создания и управления микросервисами.



Примеры использования Spring Cloud
Вот несколько примеров использования Spring Cloud:

Управление конфигурацией: Spring Cloud Config позволяет хранить конфигурацию микросервисов в централизованном репозитории и обновлять ее без перезапуска приложений.

Регистрация и обнаружение сервисов: Spring Cloud Netflix Eureka предоставляет механизмы для регистрации и обнаружения микросервисов в распределенной среде.

Управление межсервисными вызовами: Spring Cloud Netflix Ribbon предоставляет балансировку нагрузки между экземплярами микросервисов и обработку ошибок при межсервисных вызовах.

Цепочки обработки запросов: Spring Cloud Gateway позволяет создавать гибкие цепочки обработки запросов, где каждый микросервис выполняет определенные операции над запросом.

Мониторинг и трассировка: Spring Cloud Sleuth и Zipkin предоставляют инструменты для мониторинга и трассировки микросервисов.

Управление отказами и восстановлением: Spring Cloud Netflix Hystrix предоставляет механизмы для управления отказами и восстановления в микросервисных системах.

Масштабирование: Spring Cloud Kubernetes позволяет масштабировать микросервисы в Kubernetes-кластере.

Это только некоторые примеры использования Spring Cloud. Он предлагает множество других инструментов и возможностей для разработки и управления микросервисными приложениями.



## 18. Какая польза от аннотаций WebMvcTest в приложениях Spring MVC?

WebMvcTest - это аннотация в Spring MVC, которая предназначена для тестирования контроллеров веб-приложений. Она позволяет создавать юнит-тесты для контроллеров, без необходимости запуска всего веб-приложения. Аннотация WebMvcTest автоматически настраивает только необходимые компоненты, связанные с веб-слоем, такие как контроллеры, обработчики и представления.

Польза от аннотаций WebMvcTest в приложениях Spring MVC заключается в следующем:

Ускорение тестирования: Использование аннотации WebMvcTest позволяет проводить тестирование контроллеров без необходимости запуска всего веб-приложения. Это значительно сокращает время выполнения тестов и ускоряет процесс разработки.

Изоляция тестов: Аннотация WebMvcTest автоматически настраивает только необходимые компоненты, связанные с веб-слоем. Это позволяет изолировать тесты контроллеров от других компонентов приложения, таких как сервисы или база данных. Такая изоляция облегчает обнаружение и исправление ошибок.

Удобство настройки: Аннотация WebMvcTest автоматически настраивает необходимые зависимости и бины для тестирования контроллеров. Это упрощает процесс настройки тестов и позволяет сосредоточиться на проверке функциональности контроллеров.

Повышение надежности: Тестирование контроллеров с использованием аннотации WebMvcTest помогает обнаруживать ошибки и проблемы взаимодействия между компонентами веб-слоя. Это позволяет повысить надежность приложения и улучшить качество кода.

В целом, использование аннотации WebMvcTest в приложениях Spring MVC позволяет упростить и ускорить процесс тестирования контроллеров, обеспечивая при этом высокую надежность и удобство настройки тестов.




## 19. Какие существуют типы тестирования микросервисов?

Существует несколько типов тестирования микросервисов, которые помогают обеспечить их надежность и работоспособность. Вот некоторые из них:

Юнит-тестирование: это тестирование, которое проверяет отдельные компоненты микросервисов, такие как функции или классы. Оно позволяет проверить, что каждая часть работает правильно в изоляции.

Интеграционное тестирование: этот тип тестирования проверяет взаимодействие между различными микросервисами. Он позволяет убедиться, что микросервисы взаимодействуют друг с другом корректно и передают правильные данные.

Тестирование производительности: это тестирование, которое проверяет, как микросервисы работают под нагрузкой. Оно позволяет оценить производительность системы и выявить возможные узкие места.

Тестирование безопасности: этот тип тестирования направлен на проверку безопасности микросервисов. Оно помогает выявить уязвимости и обеспечить защиту от возможных атак.

Тестирование восстановления после сбоев: это тестирование, которое проверяет, как микросервисы восстанавливаются после сбоев или ошибок. Оно позволяет убедиться, что система может быстро восстановиться и продолжать работать без проблем

## 20. Что вы понимаете в распределенной транзакции?

Распределенная транзакция - это транзакция, которая включает в себя несколько отдельных операций, выполняемых на разных узлах или системах. Она обеспечивает атомарность, согласованность, изолированность и долговечность (ACID) для всех операций, выполняемых в рамках транзакции.

ACID - это акроним, который описывает основные свойства распределенных транзакций:

+ Атомарность (Atomicity): Транзакция считается атомарной, если все ее операции выполняются как единое целое. Если одна операция не может быть выполнена, то все операции отменяются и возвращается исходное состояние системы.
+ Согласованность (Consistency): Транзакция должна приводить систему из одного согласованного состояния в другое согласованное состояние. Это означает, что все ограничения целостности данных должны быть соблюдены.
+ Изолированность (Isolation): Каждая транзакция должна быть изолирована от других транзакций, выполняющихся параллельно. Это гарантирует, что результаты одной транзакции не будут видны другим транзакциям до ее завершения.
+ Долговечность (Durability): После успешного завершения транзакции ее результаты должны быть сохранены и доступны даже в случае сбоя системы.

Распределенные транзакции широко используются в системах, где данные и операции над ними распределены по нескольким узлам или системам. Они обеспечивают целостность данных и гарантируют, что все операции будут выполнены успешно или откатятся в случае сбоя.

Примеры распределенных транзакций включают в себя:

+ Транзакции в базах данных, которые реплицируют данные на несколько узлов для обеспечения отказоустойчивости и масштабируемости.
+ Транзакции в системах электронной коммерции, где покупка товара может включать операции на разных серверах для проверки наличия товара, списания средств и обновления инвентаря.
+ Транзакции в системах банковского дела, где перевод денежных средств может включать операции на разных банковских системах для проверки баланса и обновления счетов.
+ Распределенные транзакции могут быть сложными в реализации и требуют специальных протоколов и алгоритмов для обеспечения ACID-свойств. Однако, они играют важную роль в обеспечении надежности и целостности данных в распределенных системах.

21. Что такое идемпотенция и где она используется?

Идемпотенция: определение и использование
Идемпотенность - это свойство операции, которое гарантирует, что повторное выполнение операции не приведет к изменению состояния системы после первого выполнения. Другими словами, если операция выполняется несколько раз, результат будет таким же, как и при первом выполнении.

Идемпотенность является важным понятием в разработке микросервисов и используется для обеспечения надежности и предсказуемости системы. Вот несколько примеров, где идемпотенность может быть применена:

+ HTTP методы: Некоторые HTTP методы, такие как GET и HEAD, являются идемпотентными, поскольку они не изменяют состояние сервера. Это означает, что повторные запросы с теми же параметрами не приведут к изменению данных на сервере.
+ Транзакции: В базах данных идемпотентность может быть использована для обеспечения надежности транзакций. Если транзакция не завершится успешно, ее можно повторить без изменения состояния базы данных.
+ Сетевые операции: При выполнении сетевых операций, таких как отправка сообщений или запросов к внешним сервисам, идемпотентность может быть использована для обеспечения надежности. Если операция не завершится успешно, ее можно повторить без нежелательных побочных эффектов.

Идемпотентность является важным принципом в разработке микросервисов, поскольку она позволяет обеспечить надежность и предсказуемость системы. При проектировании микросервисов разработчики должны учитывать идемпотентность и применять соответствующие методы и практики для обеспечения этого свойства.

Пример использования идемпотентности
Допустим, у нас есть микросервис для обработки платежей. Когда клиент отправляет запрос на проведение платежа, микросервис должен обработать этот запрос и обновить соответствующую информацию в базе данных. Чтобы обеспечить идемпотентность операции, микросервис может использовать уникальный идентификатор запроса (например, UUID), который будет передаваться в каждом запросе. Если микросервис получает повторный запрос с тем же идентификатором, он будет игнорировать этот запрос, поскольку он уже обработан. Это позволяет избежать дублирования платежей и нежелательных побочных эффектов.

Заключение
Идемпотентность - это свойство операции, которое гарантирует, что повторное выполнение операции не приведет к изменению состояния системы после первого выполнения. Идемпотентность используется в разработке микросервисов для обеспечения надежности и предсказуемости системы. Она может быть применена в различных контекстах, таких как HTTP методы, транзакции и сетевые операции.

22. Что такое ограниченный контекст?

Ограниченный контекст (Bounded Context) - это концепция, введенная в методологии разработки программного обеспечения под названием "Domain-Driven Design" (DDD). Ограниченный контекст представляет собой границу, внутри которой определенный микросервис функционирует и управляет своей собственной моделью данных и бизнес-логикой. Он определяет явные границы и контекст для определенной области бизнеса или функциональности приложения.

Ограниченный контекст помогает разработчикам разделить сложные системы на более мелкие и понятные части, что упрощает разработку, тестирование и поддержку приложения. Каждый ограниченный контекст может иметь свою собственную модель данных, базу данных и интерфейсы для взаимодействия с другими микросервисами. Это позволяет разработчикам работать над каждым ограниченным контекстом независимо и эффективно масштабировать систему.

Примеры принципов микросервисной архитектуры:

+ Smart endpoints and dumb pipes: Микросервисы должны быть самодостаточными и иметь "умные" (интеллектуальные) точки входа, которые обрабатывают бизнес-логику, в то время как коммуникация между сервисами должна быть простой и прозрачной.
+ Design for failure: При разработке микросервисов необходимо учитывать возможность сбоев и отказов. Каждый сервис должен быть спроектирован таким образом, чтобы обрабатывать сбои и восстанавливаться без проблем.
+ Decentralized data management: Каждый микросервис может иметь свою собственную базу данных или модель данных, что позволяет избежать централизованного хранения данных и улучшает масштабируемость и гибкость системы.

Ограниченный контекст и микросервисы позволяют создавать гибкие, масштабируемые и легко поддерживаемые приложения. Они помогают разработчикам разделить сложные системы на более мелкие и понятные части, что упрощает разработку и обеспечивает более эффективное использование ресурсов.

23. Что такое двухфакторная аутентификация?

Двухфакторная аутентификация (2FA) - это метод обеспечения безопасности, который требует от пользователя предоставить два разных фактора для подтверждения своей личности при входе в систему или выполнении чувствительных операций. Это добавляет дополнительный уровень защиты, так как злоумышленникам будет сложнее получить доступ к аккаунту, даже если они украдут или угадают пароль.

Обычно двухфакторная аутентификация включает в себя комбинацию следующих факторов:

+ Что-то, что вы знаете: это может быть пароль, пин-код или ответ на секретный вопрос.
+ Что-то, что вы имеете: это может быть физическое устройство, такое как смартфон, USB-ключ или специальное устройство для генерации одноразовых паролей.
+ Что-то, что вы являетесь: это может быть биометрический фактор, такой как скан отпечатка пальца, распознавание лица или голоса.

Комбинация этих факторов обеспечивает более надежную аутентификацию и защиту от несанкционированного доступа к аккаунту или системе.

24. Какие типы учетных данных используются для двухфакторной аутентификации?

Двухфакторная аутентификация (2FA) - это метод обеспечения безопасности, который требует от пользователя предоставить два разных типа учетных данных для подтверждения своей личности. Это обычно включает в себя что-то, что пользователь знает (например, пароль) и что-то, что пользователь имеет (например, устройство для получения одноразового кода).

Типы учетных данных, используемых для двухфакторной аутентификации, могут включать:

+ Пароль: Пользователь должен ввести свой пароль, который известен только ему. Пароль должен быть достаточно сложным и уникальным, чтобы предотвратить угадывание или взлом.
+ Одноразовый код: Пользователь получает одноразовый код на свое устройство, например, на мобильный телефон или электронную почту. Этот код обычно действителен только в течение ограниченного времени и используется вместе с паролем для подтверждения личности.
+ Биометрические данные: Некоторые системы могут использовать биометрические данные, такие как отпечаток пальца, сканирование сетчатки глаза или распознавание лица, для подтверждения личности пользователя.
+ Аппаратные устройства: Некоторые организации могут использовать специальные аппаратные устройства, такие как USB-ключи или смарт-карты, для генерации одноразовых кодов или подтверждения личности пользователя.

Важно отметить, что конкретные типы учетных данных, используемых для двухфакторной аутентификации, могут различаться в зависимости от конкретной системы или провайдера услуг.

25. Что такое сертификат клиента?

Сертификат клиента - это цифровой документ, который используется для аутентификации клиента в системе. Он содержит информацию о клиенте, такую как его идентификатор, открытый ключ и другие данные, которые могут быть использованы для проверки подлинности клиента.

Сертификат клиента обычно выдается центром сертификации (Certificate Authority, CA) и подписывается его приватным ключом. При аутентификации клиента, сервер может запросить предоставление сертификата клиента, а затем проверить его подлинность, используя публичный ключ CA.

Сертификаты клиента широко используются в различных областях, таких как веб-безопасность, электронная коммерция и сетевые протоколы. Они обеспечивают безопасное взаимодействие между клиентом и сервером, а также защиту от подделки и несанкционированного доступа.


26. Какова цель PACT в микросервисной архитектуре?
PACT (Provider and Consumer Testing) - это инструмент для тестирования и контрактного тестирования между поставщиком и потребителем в микросервисной архитектуре. Основная цель PACT - это обеспечение согласованности и надежности взаимодействия между сервисами.

В микросервисной архитектуре, где разные сервисы общаются друг с другом, важно, чтобы каждый сервис знал, какие запросы и ответы ожидать от других сервисов. PACT помогает достичь этого, путем создания контрактов между поставщиком и потребителем.

Поставщик - это сервис, который предоставляет API или функционал, который другие сервисы используют. Потребитель - это сервис, который использует функционал поставщика.

С помощью PACT, поставщик и потребитель могут создать контракт, который описывает ожидаемые запросы и ответы между ними. Контракт определяет, какие данные должны быть переданы, какие методы должны быть вызваны и какие коды состояния ожидаются. Контракт может быть записан в специальном формате, таком как JSON или YAML.

Когда контракт создан, он может быть использован для автоматического тестирования взаимодействия между поставщиком и потребителем. Это позволяет обнаружить возможные проблемы и несоответствия взаимодействия до того, как они станут проблемами в реальной среде.

Таким образом, цель PACT в микросервисной архитектуре заключается в обеспечении согласованности и надежности взаимодействия между сервисами путем создания контрактов и автоматического тестирования. Это помогает улучшить качество и надежность микросервисной архитектуры.

27. Что такое OAuth?

OAuth (Open Authorization) - это открытый протокол авторизации, который позволяет пользователям предоставлять доступ к своим данным на одном веб-сайте третьей стороне без необходимости передавать свои учетные данные. Это позволяет пользователям безопасно авторизоваться на различных веб-сайтах и приложениях, используя учетные данные с одного источника.

Основная идея OAuth заключается в том, что пользователь предоставляет доступ третьей стороне к своим данным, но без раскрытия своего пароля или других учетных данных. Вместо этого, после успешной аутентификации на веб-сайте или приложении, пользователь получает специальный токен доступа, который может быть использован третьей стороной для доступа к определенным данным пользователя на веб-сайте или в приложении.

Протокол OAuth состоит из нескольких этапов:

Регистрация приложения: Разработчик регистрирует свое приложение на веб-сайте, который поддерживает протокол OAuth.
Аутентификация пользователя: Пользователь аутентифицируется на веб-сайте или приложении, предоставляя свои учетные данные.
Предоставление разрешения: Веб-сайт или приложение запрашивает у пользователя разрешение на доступ к определенным данным.
Выдача токена доступа: Если пользователь дает согласие, веб-сайт или приложение выдают токен доступа третьей стороне.
Доступ к данным: Третья сторона использует токен доступа для получения доступа к данным пользователя на веб-сайте или в приложении.
OAuth широко используется в различных областях, включая социальные сети, онлайн-сервисы и API. Например, многие социальные сети, такие как Facebook, Twitter и Google, используют OAuth для авторизации пользователей и предоставления доступа к их данным третьим сторонам.

Пример использования OAuth:
Представим, что у вас есть приложение, которое позволяет пользователям делиться своими фотографиями на Instagram. Вместо того, чтобы просить пользователей предоставить вам свои учетные данные Instagram, вы можете использовать OAuth для авторизации пользователей и получения доступа к их фотографиям. В этом случае, после успешной аутентификации пользователя на Instagram, ваше приложение получит токен доступа, который может быть использован для получения доступа к фотографиям пользователя на Instagram.

Важно отметить, что OAuth не предоставляет конфиденциальность данных. Он предназначен только для авторизации и предоставления доступа к данным. Защита данных должна быть обеспечена другими механизмами, такими как HTTPS.

Примечания:
OAuth 2.0 является наиболее распространенной версией протокола OAuth.
OAuth используется в различных языках программирования и платформах, включая Python и JavaScript.

28. Что такое OAuth 2.0?
OAuth 2.0 - это протокол авторизации, который позволяет пользователям предоставлять доступ к своим данным третьим сторонам без необходимости раскрытия своих учетных данных (логина и пароля). Он широко используется в веб-приложениях и мобильных приложениях для авторизации пользователей и получения доступа к их защищенным ресурсам.

Основные принципы OAuth 2.0:
+ Разделение ролей: OAuth 2.0 разделяет роли между клиентом (приложением, запрашивающим доступ), провайдером авторизации (сервисом, предоставляющим доступ к ресурсам пользователя) и пользователем.
+ Авторизация через согласие: Пользователь дает согласие на предоставление доступа третьей стороне без раскрытия своих учетных данных.
+ Выдача токенов доступа: После успешной авторизации провайдер авторизации выдает токен доступа, который клиент может использовать для получения доступа к защищенным ресурсам пользователя.
+ Ограничение прав доступа: OAuth 2.0 позволяет определить различные уровни доступа для клиентов, чтобы ограничить их возможности взаимодействия с ресурсами пользователя.


Пример использования OAuth 2.0:
+ Пользователь открывает приложение, которое запрашивает доступ к его аккаунту на другом сервисе.
+ Приложение перенаправляет пользователя на страницу авторизации провайдера авторизации.
+ Пользователь вводит свои учетные данные на странице провайдера авторизации.
+ Провайдер авторизации проверяет учетные данные пользователя и запрашивает у него разрешение на предоставление доступа приложению.
+ Если пользователь дает согласие, провайдер авторизации выдает токен доступа приложению.
+ Приложение использует полученный токен доступа для получения доступа к защищенным ресурсам пользователя.

29. Что такое закон Конвея?
Закон Конвея говорит о том, что программы, приложения и любые другие IT–продукты отражают ценности людей, которые их создают. То есть функционал, дизайн, принципы работы зависят от команды разработчиков. В Википедии про Закон Конвея сказано так: «организации разрабатывают системы, которые являются зеркальным отражением их собственной коммуникационной структуры». Проще говоря, продукт и команда — это одно целое.

30. Что вы знаете о тестировании контрактов?

Тестирование контрактов - это подход к тестированию микросервисной архитектуры, который заключается в проверке согласованности интерфейсов и взаимодействия между различными сервисами. Контракт представляет собой набор правил и ожиданий, которые определяют, как один сервис может взаимодействовать с другими сервисами.

Основная цель тестирования контрактов - убедиться, что все сервисы взаимодействуют друг с другом согласно ожиданиям и спецификациям. Это помогает предотвратить ошибки и проблемы, связанные с неправильными запросами и ответами между сервисами.

Тестирование контрактов может включать следующие аспекты:

1. Тестирование согласованности интерфейсов: Проверка, что каждый сервис предоставляет ожидаемые методы и параметры, а также возвращает ожидаемые результаты.

2. Тестирование взаимодействия: Проверка, что запросы и ответы между сервисами соответствуют ожидаемым контрактам. Это включает проверку формата данных, кодов состояния HTTP, обработку ошибок и другие аспекты взаимодействия.

3. Тестирование масштабируемости: Проверка, что система может масштабироваться горизонтально путем добавления дополнительных экземпляров сервисов без нарушения контрактов и функциональности.

4. Тестирование безопасности: Проверка, что взаимодействие между сервисами защищено и соответствует установленным правилам безопасности.

5. Тестирование производительности: Проверка, что система может обрабатывать запросы и взаимодействовать с другими сервисами с требуемой производительностью и задержкой.

Тестирование контрактов может быть автоматизировано с использованием специальных инструментов и фреймворков, которые позволяют создавать и запускать тесты контрактов автоматически.

31. Что такое сквозное тестирование микросервисов?

Сквозное тестирование микросервисов - это процесс проверки системы, состоящей из нескольких микросервисов, с целью обнаружения и исправления проблем, возникающих при взаимодействии между сервисами. Оно основано на тестировании потока данных от одного микросервиса к другому, чтобы убедиться, что данные правильно передаются и обрабатываются в каждом сервисе.

При сквозном тестировании микросервисов проверяются не только отдельные сервисы по отдельности, но и их взаимодействие друг с другом, а также с внешними системами или компонентами. Это позволяет выявить потенциальные проблемы, такие как неправильная передача данных, неправильное форматирование или ошибки в логике обработки данных.

Для проведения сквозного тестирования микросервисов используются различные методы, включая симуляцию запросов и ответов между сервисами, мониторинг и анализ логов, а также создание тестовых сред и сценариев для воспроизведения конкретных ситуаций.

В результате сквозного тестирования микросервисов можно получить подробное представление о работе всей системы в целом, а также выявить и устранить возможные проблемы, которые могут повлиять на работу отдельных компонентов или всей системы в целом. Это помогает обеспечить стабильность, надежность и безопасность микросервисной архитектуры.

32. Для чего нужен контейнер в микросервисах?

Контейнеры играют важную роль в архитектуре микросервисов. Они представляют собой легковесное и изолированное окружение, в котором можно запускать и работать с отдельными микросервисами. Вот несколько причин, почему контейнеры важны для микросервисной архитектуры:

1. Изолированное окружение: Контейнеры обеспечивают изоляцию между различными микросервисами. Каждый контейнер имеет свои собственные ресурсы и зависимости, что позволяет избежать конфликтов и обеспечить надежную работу каждого микросервиса.

2. Портативность: Контейнеры позволяют упаковать микросервисы и их зависимости вместе с необходимыми настройками и конфигурацией. Это делает их переносимыми между различными средами выполнения, такими как различные операционные системы или облачные платформы.

3. Масштабируемость: Контейнеры облегчают горизонтальное масштабирование микросервисов. Поскольку каждый контейнер работает в изолированном окружении, его можно легко развернуть и масштабировать независимо от других контейнеров.

4. Управление зависимостями: Контейнеры позволяют управлять зависимостями микросервисов. Каждый контейнер может иметь свои собственные зависимости и версии библиотек, что облегчает управление и обновление каждого микросервиса отдельно.

5. Упрощенная разработка и развертывание: Контейнеры упрощают процесс разработки и развертывания микросервисов. Разработчики могут создавать и тестировать микросервисы в контейнерах на своих локальных машинах, а затем легко развертывать их в продакшн среде без необходимости настройки окружения на каждом сервере.

6. Гибкость и масштабируемость инфраструктуры: Контейнеры позволяют гибко масштабировать инфраструктуру для обеспечения требуемой производительности и доступности микросервисов. Контейнеры могут быть развернуты на физических серверах, виртуальных машинах или облачных платформах.

Контейнеры, такие как Docker, являются популярным выбором для реализации микросервисной архитектуры, так как они предоставляют удобные инструменты для создания, управления и развертывания контейнеров.

33. Что такое DRY в микросервисной архитектуре?
DRY (Don't Repeat Yourself) - это принцип разработки программного обеспечения, который призывает избегать повторения кода или логики в разных частях системы. В контексте микросервисной архитектуры, принцип DRY означает, что каждый микросервис должен быть ответственным только за свою собственную функциональность и не должен повторять код или логику, которая уже реализована в других микросервисах.

Принцип DRY помогает улучшить поддерживаемость и расширяемость системы, поскольку изменения в одном микросервисе не требуют изменений в других микросервисах. Это также способствует уменьшению сложности системы и повышению ее надежности.

Вместо повторения кода или логики, микросервисы могут обмениваться данными или вызывать друг друга через API. Это позволяет каждому микросервису быть независимым и легко масштабируемым.

Принцип DRY является одним из принципов SOLID (SOLID - Single responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion), которые помогают создавать гибкие и поддерживаемые системы.

Важно помнить, что принцип DRY не означает, что никогда не должно быть повторений кода. Он призывает избегать ненужного повторения и настоятельно рекомендует выносить общую функциональность в отдельные модули или сервисы, чтобы избежать дублирования и упростить поддержку системы.

34. Что такое договор, ориентированный на потребителя (CDC Consumer-Driven Contracts)?

Consumer-Driven Contracts (CDC) - это практика разработки программного обеспечения, которая позволяет установить контракты между производителями (провайдерами) и потребителями (клиентами) сервисов. CDC в основном используется в микросервисной архитектуре, где различные сервисы взаимодействуют друг с другом.

CDC предполагает, что потребители определяют контракты, описывающие ожидаемое поведение производителя. Такие контракты могут быть специфичными для каждого клиента и описывать различные сценарии использования. Контракты могут включать описание запросов и ожидаемых ответов, включая структуру данных, форматы сообщений и возможные ошибки.

Одной из особенностей CDC является то, что контракты разрабатываются потребителями, а не производителями. Потребители могут определить свои требования и отправить их производителям. Затем производители должны соответствовать этим контрактам, чтобы обеспечить совместимость и надежность своих сервисов.

CDC помогает улучшить коммуникацию между потребителями и производителями сервисов. Он позволяет установить ясные ожидания относительно поведения сервиса и обеспечить согласованность между различными компонентами системы. Кроме того, CDC способствует ускорению развертывания и обновления сервисов, так как изменения в контрактах могут быть легко обнаружены и учтены.

В заключение, CDC - это методология, которая позволяет установить контракты между потребителями и производителями сервисов, обеспечивая согласованность и надежность в микросервисной архитектуре. Это помогает улучшить коммуникацию и ускорить развертывание сервисов.

35. Какова роль Web и RESTful API в микросервисах?
Web и RESTful API играют важную роль в архитектуре микросервисов. В микросервисной архитектуре, приложение разбивается на небольшие, автономные и независимые сервисы, которые взаимодействуют друг с другом через сеть.

Веб является основной платформой для взаимодействия с микросервисами. Каждый сервис может предоставлять свой собственный веб-интерфейс, через который пользователи или другие сервисы могут получать доступ к его функциональности. Веб-интерфейс может быть представлен в виде веб-страниц, апи-порталов или приложений.

RESTful API (Representational State Transfer) является популярным подходом к созданию веб-сервисов. Он определяет набор принципов и ограничений для создания легко масштабируемых и расширяемых API. RESTful API использует стандартные HTTP методы, такие как GET, POST, PUT и DELETE, для взаимодействия с ресурсами.

Роль Web и RESTful API в микросервисах заключается в обеспечении связи и взаимодействия между отдельными сервисами. Каждый сервис может предоставлять свои API, которые позволяют другим сервисам или клиентским приложениям обмениваться данными и использовать функциональность предоставляемую этими сервисами.

Web и RESTful API также обеспечивают гибкость и независимость каждого сервиса. Каждый сервис может разрабатываться и масштабироваться независимо от других сервисов, что упрощает разработку и обслуживание системы в целом.

В целом, Web и RESTful API играют ключевую роль в микросервисной архитектуре, обеспечивая взаимодействие и связность между сервисами, а также гибкость и независимость каждого сервиса.

36. Что вы знаете о семантическом мониторинге в микросервисной архитектуре?
37. Как мы проводим кросс-функциональное тестирование?
38. Как устранить недетерминизм в тестировании?
39. В чем разница между макетом и заглушкой?
40. Что вы знаете о тестовой пирамиде Майка Кона?
41. Какова цель Докера?
42. Что такое канареечный релиз (Canary Releasing)?
43. Что такое непрерывная интеграция (CI)?
44. Что такое непрерывный мониторинг?
45. Какова роль архитектора в микросервисной архитектуре?
46. Можем ли мы использовать микросервисы для создания конечных автоматов?
47. Что такое реактивное расширение в микросервисах?



Вопросы на собеседовании SpringCloud

47. Что такое Spring Cloud?
48. Каковы преимущества использования Spring Cloud?
49. Что означает регистрация и обнаружение службы? Как достичь Spring Cloud?
50. В чем разница между Spring Cloud и dubbo?
51. В чем разница между SpringBoot и SpringCloud?
52. Какое значение имеет балансировка нагрузки?
53. Что такое Hystrix? Как добиться отказоустойчивости?
54. Что такое автоматический выключатель Hystrix? Оно нам нужно?
55. Что такое Netflix Feign? В чем его преимущества?
56. Что такое Spring Cloud Bus? Оно нам нужно?
57. роль автоматического выключателя springcloud
58. Что такое SpringCloudConfig?
59. Spring Cloud Gateway?


20 Основных вопросов для собеседования по архитектуре микросервисов

60. Что такое архитектура микросервисов и чем она отличается от монолитной архитектуры?
61. Как спроектировать и внедрить микросервисы?
62. Каковы ключевые характеристики хорошо спроектированного микросервиса?
63. Что такое связность в микросервисах? Какая она бывает?
64. Как микросервис Java и микросервис .NET могут взаимодействовать с teach? (подсказка: json)
65. Как решать сквозные проблемы, такие как безопасность, в архитектуре микросервисов?
66. Почему отладка так сложна в микросервисной архитектуре?
67. Как обеспечить согласованность данных в архитектуре микросервисов?
68. Как гарантировать, что микросервисы масштабируемы и устойчивы?
69. Как обрабатывать обнаружение и регистрацию служб в архитектуре микросервисов?
70. Как управлять взаимодействием служб и совместным использованием данных в архитектуре микросервисов?
71. Как управлять версиями сервисов и обратной совместимостью в архитектуре микросервисов?
72. Как отслеживать микросервисы и устранять неполадки в них?
73. Как обрабатывать развёртывания и откаты в архитектуре микросервисов?
74. Как справиться с тестированием и непрерывной интеграцией в архитектуре микросервисов?
75. В архитектуре микросервисов тестирование и непрерывная интеграция должны выполняться на уровне сервиса, с автоматизированными тестами и непрерывным конвейером доставки для каждой службы. Это позволяет осуществлять независимое развёртывание и масштабирование служб.
76. Как управлять жизненным циклом в архитектуре микросервисов?
77. Как обеспечить безопасность и контроль доступа в архитектуре микросервисов?
78. Как вы осуществляете интеграцию данных и миграцию данных в архитектуре микросервисов?
79. Как управлять составом и оркестровкой сервисов в архитектуре микросервисов?
80. Как вы развертываете свои микросервисы Java?
81. Как обеспечить отказоустойчивость сервиса в случае сбоев?
82. Какие фреймворки Java вы можете использовать для создания микросервисов?
83. Сколько микросервисов содержится в вашем проекте? Как вы находите их, если пользователь говорит, что один из его заказов отсутствует в базе данных? (подсказка — одна база данных на микросервис – это шаблон).




  15 Вопросов для собеседования по микросервисам о шаблонах и принципах проектирования

84. Что такое шаблон Gateway API и как он используется в архитектуре микросервисов? Пожалуйста, объясните, какую проблему он решает и является ли он обязательным для микросервисов или нет?
85. Можете ли вы объяснить схему автоматического выключателя и как она используется для обработки сбоев обслуживания в архитектуре микросервисов? Какую проблему это решает.
86. Что такое шаблон Command Query Responsibility Segregation (CQRS) и когда его целесообразно использовать в архитектуре микросервисов?
87. Что такое Retry pattern в микросервисах? Когда и как его использовать?
88. Зачем нежен Explain Event-Driven шаблон и как его используют в микросервисной архитектуре?
89. Зачем нежен Explain Service Registry шаблон и как его используют в микросервисной архитектуре?
90. Зачем нежен Explain Sidecar шаблон и как его используют в микросервисной архитектуре?
91. Зачем нежен Explain Backend for Frontend шаблон и как его используют в микросервисной архитектуре?
92. Зачем нежен Explain Bulkhead шаблон и как его используют в микросервисной архитектуре?
93. Зачем нежен Saga шаблон и как его используют в микросервисной архитектуре?
94. Зачем нежен Explain Outbox  шаблон и как его используют в микросервисной архитектуре?
95. Зачем нежен Self-Containment шаблон и как его используют в микросервисной архитектуре?
96. Зачем нежен Explain External Configuration шаблон и как его используют в микросервисной архитектуре?
97. Зачем нежен Strangler шаблон и как его используют в микросервисной архитектуре?







15 Вопросов для о микросервисах для опытных разработчиков



1. Как выполнить секционирование данных и репликацию данных в MS?
2. Выполняли ли вы какое-либо разделение служб и масштабирование служб в архитектуре микросервисов? Если нет, то как вы можете это сделать?
3. Объясните организацию обслуживания и хореографию обслуживания в микросервисах?
4. С какими проблемами вы сталкивались при разработке микросервисов в вашем проекте?
5. Как вы справляетесь с безопасностью служб и шифрованием служб в микросервисах?
6. Как вы будете реализовывать мониторинг служб и ведение журнала служб в архитектуре микросервисов?
7. Как вы справляетесь с отслеживанием служб и отладкой служб в архитектуре микросервисов?
8. Что такое тестирование сервиса и обеспечение качества сервиса в архитектуре микросервисов?
9. Как вы справляетесь с развертыванием служб и их откатом в архитектуре микросервисов?
10. Как вы справляетесь с управлением сервисами и жизненным циклом сервисов в архитектуре микросервисов?
11. Как вы справляетесь с миграцией служб и модернизацией сервисов в архитектуре микросервисов?
12. Как вы справляетесь с интеграцией сервисов и управлением API сервисов в архитектуре микросервисов?
13. Как вы справляетесь с производительностью сервиса и оптимизацией сервиса в архитектуре микросервисов?
14. Как убедиться, что ваши микросервисы не влияют на другие микросервисы на том же хосте?
15. Как вы организуете свои микросервисы? Остаётся ли весь код в одном и том же репозитории или вы создаёте несколько репозиториев для разных микросервисов?
16. Что лучше: разная база данных для разных микросервисов или единая база данных для всех микросервисов? Почему?1.